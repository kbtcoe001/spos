#include <bits/stdc++.h>
using namespace std;

const int N = 100005;

void lru_page_replacement(int frame_size, int n, int pages[]) {
    unordered_map<int, list<int>::iterator> pageTable;
    list<int> lruQueue; // Doubly linked list to maintain the order of page access
    int page_faults = 0;
    int page_hits = 0;

    for (int i = 0; i < n; i++) {
        int page = pages[i];

        // Check if the page is in memory
        if (pageTable.find(page) != pageTable.end()) {
            // Page found in memory, update its position in the LRU queue
            lruQueue.erase(pageTable[page]);
            page_hits++;
        } else {
            // Page not found in memory, increment page fault counter
            page_faults++;

            // Check if the frame size is exceeded
            if (lruQueue.size() >= frame_size) {
                int lruPage = lruQueue.back();
                lruQueue.pop_back();
                pageTable.erase(lruPage);
            }
        }

        // Add the current page to the front of the LRU queue
        lruQueue.push_front(page);
        pageTable[page] = lruQueue.begin();

        cout << "Iteration " << i + 1 << ": Page Reference = " << page << ", Frames = [";
        for (auto it = lruQueue.begin(); it != lruQueue.end(); ++it) {
            cout << *it;
            if (next(it) != lruQueue.end()) {
                cout << ", ";
            }
        }
        cout << "], Page Faults = " << page_faults << ", Page Hits = " << page_hits << endl;
    }
}

int main() {
    int frame_size = 4;
    int pages[N];
    int n;

    cout << "Page Reference Stream Length: ";
    cin >> n;
    cout << "Page Reference Stream:\n";
    for (int i = 0; i < n; i++)
        cin >> pages[i];

    lru_page_replacement(frame_size, n, pages);
    return 0;
}
